/*H************************************************************************************************
 * FILENAME:        bluetooth_hal.c
 *
 * DESCRIPTION:
 *      Bluetooth Hardware Abstraction Layer (HAL), this source file provides an abstraction over
 *      the UART communications with the Bluetooth Low Energy (BLE) module (HC-08 v2.2).
 *
 * PUBLIC FUNCTIONS:
 *      void    BT_HAL_init()
 *      void    BT_HAL_sendMessage(const char* format, ...)
 *      void    BT_HAL_registerMessageCallback(BTCallback callback)
 *
 * NOTES:
 *      Every time that a reception interrupt is generated by the eUSCI module related to the
 *      Bluetooth the IRQHandler provided in this file will read the incoming message and invoke
 *      the callback function.
 *
 * AUTHOR: Andrea Piccin    <andrea.piccin@studenti.unitn.it>
 *
 * START DATE: 01 Feb 2024
 *
 * CHANGES:
 * DATE         AUTHOR          DETAIL
 * 04 Feb 2024  Andrea Piccin   Refactoring
 * 09 Feb 2024  Andrea Piccin   Introduced callback mechanism
 * 10 Feb 2024  Andrea Piccin   Fixed multiple message transmission adding a queue
 * 12 Feb 2024  Andrea Piccin   introduced printf-like sendMessage function
 */
#include <stdarg.h>
#include <stdio.h>

#include "../../inc/bluetooth_hal.h"
#include "../../inc/queue.h"

#define BT_PORT GPIO_PORT_P3        /* Bluetooth I/O port                          */
#define BT_RX_PIN GPIO_PIN2         /* Bluetooth RX pin                            */
#define BT_TX_PIN GPIO_PIN3         /* Bluetooth TX pin                            */
#define BT_EUSCI_BASE EUSCI_A2_BASE /* eUSCI module used for UART communications   */
#define BT_EUSCI_INT INT_EUSCIA2    /* eUSCI interrupt related to the eUSCI module */
#define BT_BUFFER_SIZE 256          /* Max size of the unread message              */

/*T************************************************************************************************
 * NAME: TxState
 *
 * DESCRIPTION:
 *      Represent the state of the transmission routine.
 *
 * SPECIFICATIONS:
 *      Type:       enum
 *      Values:     TX_IDLE         When no message is being transmitted
 *                  TX_MESSAGE      When the body of the message is being transmitted
 *                  TX_CR           When the carriage return '\r' char have to be sent
 *                  TX_LF           When the line feed '\n' char have to be sent
 */
typedef enum { TX_IDLE, TX_MESSAGE, TX_CR, TX_LF } TxState;

BTCallback btCallback;                               /* To call when a new message is ready */
volatile char incomingMessageBuffer[BT_BUFFER_SIZE]; /* Contains the incoming message       */
volatile uint16_t currentRxIndex;                    /* Index of the current char to read   */
volatile StringQueue outgoingMessagesQueue;          /* Queue of the messages to send       */
volatile char *currentTxPointer;                     /* Pointer to the string to send       */
volatile TxState currentTxState;                     /* State the transmission              */

/*F************************************************************************************************
 * NAME: void BT_HAL_init()
 *
 * DESCRIPTION:
 *      Initialises the hardware required for the bluetooth communications:
 *      [1] Configure the RX and TX pins to be used for UART
 *      [2] Configure and enable the UART module
 *      [3] Initialise global variables
 *      [4] Enable interrupts
 *
 * INPUTS:
 *      PARAMETERS:
 *          None
 *      GLOBALS:
            None
 *
 *  OUTPUTS:
 *      PARAMETERS:
 *          None
 *      GLOBALS:
 *          uint16_t    currentRxIndex              Set to 0
 *          StringQueue outgoingMessagesQueue       Initialised
 *          char*       currentTxPointer            Set to NULL
 *          TxState     currentTxState              Set to TX_IDLE
 *          BTCallback  btCallback                  Set to NULL
 *
 *  NOTE:
 */
void BT_HAL_init() {
    Interrupt_disableMaster();
    /* [1] Configure the RX and TX pins to be used for UART */
    GPIO_setAsPeripheralModuleFunctionInputPin(BT_PORT, BT_TX_PIN | BT_RX_PIN,
                                               GPIO_PRIMARY_MODULE_FUNCTION);

    /* [2] Configure and enable the UART module */
    const eUSCI_UART_ConfigV1 BT_uartConfig = {
        EUSCI_A_UART_CLOCKSOURCE_SMCLK,               /* use SMCLK as clock source             */
        156,                                          /* scale SMCLK for a 9600 Baud Rate      */
        4,                                            /* set first modulation stage            */
        0,                                            /* set second modulation stage           */
        EUSCI_A_UART_NO_PARITY,                       /* disable parity error check            */
        EUSCI_A_UART_LSB_FIRST,                       /* least significant bit first           */
        EUSCI_A_UART_ONE_STOP_BIT,                    /* transmission pause between two bytes  */
        EUSCI_A_UART_MODE,                            /* use standard UART mode                */
        EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION /* oversampling for baud rate generation */
    };
    UART_initModule(BT_EUSCI_BASE, &BT_uartConfig);
    UART_enableModule(BT_EUSCI_BASE);

    /* [3] Initialise the global variables */
    currentRxIndex = 0;
    queue_init(&outgoingMessagesQueue);
    currentTxPointer = NULL;
    currentTxState = TX_IDLE;
    btCallback = NULL;

    /* [4] Enable interrupts */
    UART_enableInterrupt(BT_EUSCI_BASE, EUSCI_A_UART_RECEIVE_INTERRUPT);
    Interrupt_enableInterrupt(BT_EUSCI_INT);
    Interrupt_enableMaster();
}

/*F************************************************************************************************
 * NAME: void BT_HAL_sendMessage(const char* data)
 *
 * DESCRIPTION:
 *      Sends a message to the BLE module via the UART communication, the bluetooth module will
 *      forward it and every connected device will receive it, the procedure goes through the
 *      following steps:
 *      [1] Creates the message using the sprintf
 *      [2] Adds the message to the outgoing messages queue
 *      [3] Enables the transmit interrupt that signals if the transmission buffer is ready
 *      [4] The ISR will send the message
 *
 * INPUTS:
 *      PARAMETERS:
 *          const char* format              Format of the string in printf style
 *          ...         args                Like in printf
 *      GLOBALS:
 *          StringQueue outgoingMessagesQueue   Queue of the messages to send
 *
 *  OUTPUTS:
 *      PARAMETERS:
 *          None
 *      GLOBALS:
 *          StringQueue outgoingMessagesQueue    A new string is enqueued
 *
 *  NOTE:
 *      The queue has a fixed size of 10 elements, every exceeding message will be lost
 */
void BT_HAL_sendMessage(const char *format, ...) {
    if (queue_isFull(&outgoingMessagesQueue))
        return;

    // [1] Creates the message using the sprintf
    char msg[QUEUE_ELEMENT_SIZE];
    va_list args;
    va_start(args, format);
    vsnprintf(msg, sizeof(msg), format, args);
    va_end(args);

    // [2] Adds the message to the outgoing messages queue
    queue_enqueue(&outgoingMessagesQueue, msg);

    // [3] Enables the transmit interrupt
    UART_enableInterrupt(BT_EUSCI_BASE, EUSCI_A_UART_TRANSMIT_INTERRUPT);
    // [4] The ISR will send the message
}

/*F************************************************************************************************
 * NAME: void BT_HAL_registerMessageCallback(IRCallback callback)
 *
 * DESCRIPTION:
 *      Registers the given BTCallback as the function to call when a new message is ready.
 *
 * INPUTS:
 *      PARAMETERS:
 *          BTCallback      callback        The function to register as callback
 *      GLOBALS:
 *          None
 *
 *  OUTPUTS:
 *      PARAMETERS:
 *          None
 *      GLOBALS:
 *          BTCallback      btCallback      Set to callback
 *
 *  NOTE:
 */
void BT_HAL_registerMessageCallback(BTCallback callback) { btCallback = callback; }

/*F************************************************************************************************
 * NAME: void BT_HAL_forwardAndReset()
 *
 * DESCRIPTION:
 *      This function is called by the ISR and is in charge of invoking the callback function
 *      passing the new message to it, then prepares the global variables for a new reading.
 *
 * INPUTS:
 *      PARAMETERS:
 *          None
 *      GLOBALS:
 *          char*       incomingMessageBuffer       The read string
 *          BTCallback  btCallback                  The function to execute
 *
 *  OUTPUTS:
 *      PARAMETERS:
 *          None
 *      GLOBALS:
 *          uint16_t    currentRxChar   Set to zero
 *
 *  NOTE:
 */
void BT_HAL_forwardAndReset() {
    UART_disableInterrupt(BT_EUSCI_BASE, EUSCI_A_UART_RECEIVE_INTERRUPT);
    if (btCallback != NULL)
        btCallback(incomingMessageBuffer);
    currentRxIndex = 0;
    UART_enableInterrupt(BT_EUSCI_BASE, EUSCI_A_UART_RECEIVE_INTERRUPT);
}

/*ISR**********************************************************************************************
 * NAME: void EUSCIA2_IRQHandler()
 *
 * DESCRIPTION:
 *      This function is called every time that an interrupt regarding the Bluetooth EUSCI module
 *      raises, two procedures can be executed:
 *      RECEIVE_INTERRUPT:  the interrupt signals that there is a character in the RX buffer, read
 *                          it, store it in the message buffer and update the currentRxIndex; if
 *                          the end of string is read ('\n', '\r' or '\0') forward the message to
 *                          the callback function.
 *      TRANSMIT_INTERRUPT: the interrupt signals that the TX buffer is ready, the first message on
 *                          the outgoing queue is dequeued and sent followed by \r\n.
 *                          When all the messages are sent disable the transmission interrupt.
 *
 * INPUTS:
 *      GLOBALS:
 *          int             currentRxIndex          Index of the current char to read
 *          char*           currentTxPointer        Current string to send
 *          StringQueue     outgoingMessagesQueue   Queue of the messages to send
 *          TxState         currentTxState          State the transmission
 *
 *  OUTPUTS:
 *      GLOBALS:
 *          int             currentRxIndex          Incremented by one after a RX
 *          char*           incomingMessageBuffer   Updated with a new character after one RX
 *          char*           currentTxPointer        Incremented by one after a TX
 *          TxState         currentTxState          Updated
 *
 *  NOTE:
 */
// cppcheck-suppress unusedFunction
void EUSCIA2_IRQHandler(void) {
    uint32_t status = UART_getEnabledInterruptStatus(BT_EUSCI_BASE);

    /* Receive routine */
    if (status & EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG) {
        /* read the char */
        char r = UART_receiveData(BT_EUSCI_BASE);

        /* In case a message is terminated by \r\n we ignore all the extra
         * terminating characters */
        if (currentRxIndex == 0 && (r == '\n' || r == '\r' || r == '\0')) {
            return;
        }

        // if buffer overflows send the partial string
        if (currentRxIndex == BT_BUFFER_SIZE) {
            incomingMessageBuffer[BT_BUFFER_SIZE - 1] = '\0';
            BT_HAL_forwardAndReset();
            return;
        }

        // if r is a termination char invoke the callback function and prepare for the next message
        if (r == '\n' || r == '\r' || r == '\0') {
            incomingMessageBuffer[currentRxIndex] = '\0';
            BT_HAL_forwardAndReset();
        } else {
            incomingMessageBuffer[currentRxIndex] = r;
            currentRxIndex++;
        }
    }

    /* Transmit routine */
    if (status & EUSCI_A_UART_TRANSMIT_INTERRUPT_FLAG) {

        /* if the state is TX_IDLE there is no transmission, if there is a message in the queue
         * load it, otherwise disable the interrupts */
        if (currentTxState == TX_IDLE) {
            if (queue_isEmpty(&outgoingMessagesQueue)) {
                UART_disableInterrupt(BT_EUSCI_BASE, EUSCI_A_UART_TRANSMIT_INTERRUPT);
            } else {
                currentTxPointer = queue_front(&outgoingMessagesQueue);
                currentTxState = TX_MESSAGE;
            }
        }

        /* if the state is TX_MESSAGE there is a message to send, proceed with the next character,
         * if the string is terminated, switch to the TX_EOL state */
        else if (currentTxState == TX_MESSAGE) {
            if (*currentTxPointer != '\0') {
                UART_transmitData(BT_EUSCI_BASE, *currentTxPointer);
                currentTxPointer++;
            } else {
                queue_dequeue(&outgoingMessagesQueue);
                currentTxState = TX_CR;
            }
        }

        /* if the state is TX_CR or TX_LF the two termination characters (\r\n) have to be sent */
        else if (currentTxState == TX_CR) {
            UART_transmitData(BT_EUSCI_BASE, '\r');
            currentTxState = TX_LF;
        } else if (currentTxState == TX_LF) {
            UART_transmitData(BT_EUSCI_BASE, '\n');
            currentTxState = TX_IDLE;
        }
    }
}